<!--
 * @Author: five-5
 * @Description: 堆和优先队列
 * @Date: 2019-04-04
 * @LastEditTime: 2019-04-17
 -->

 
# 优先队列
- 普通队列
先进先出；后进后出
- 优先队列
出队顺序和入队顺序无关；和优先级有关
- 应用场景
    1. 医院做手术
    2. 操作系统任务调度
    </br>动态选择优先级最高的任务执行
    3. AI打怪（先打优先级最高的怪，动态过程）

# 实现
Interface Queue< E >
- void enqueue(E)
- E dequeue()
- E getFront()
- int getSize()
- bool isEmpty()

## 实现底层
有时间兴趣用1、2实现一下，练习一下
1. 普通线性结构
- 入队 O(1)  
- 出队（拿出最大的元素）O(n)
2. 顺序线性结构
- 入队O(n)
- 出队（拿出最大的元素）O(1)
3. 堆[最差复杂度情况也如下]
- 入队 O(logn) 
- 出队 O(logn) 

## 经典问题
在N个元素中选出前M个元素（M << N)
NlogM 
使用优先队列，维护当前看到的前M个元素，需要使用最小堆（因为每次需要replace掉的是这M个元素中最小的数）

# 堆
## 二叉堆
性质
1. 是一颗完全二叉树
2. 堆中某个节点的值总是不大于其父节点的值（最大堆）

用数组存储二叉堆
- 序号从1开始：parent(i) = i/2; leftc = 2 * i;  rightc = 2 * i+1
- 序号从0开始：parent(i) = (i-1)/2; left = 2 * i + 1; right = 2 * i + 2

## 实现
- add()
- ExtractMax()
时间复杂度均为o(logn)因为完全二叉树的高度为o(logn)，不会退化
- T replace(T e):取出堆中的最大元素，并且替换成元素e
- heapify(): 将任意数组整理成堆的形状

## 拓展
- d叉堆 d-ary heap
- 索引堆
- 二项堆
- 斐波拉契堆